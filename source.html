<!DOCTYPE html>
<html>
<head>
            <style>.lw { font-size: 60px; }</style>
        <style>*, ::before, ::after{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }/* ! tailwindcss v3.4.16 | MIT License | https://tailwindcss.com */*,::after,::before{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}::after,::before{--tw-content:''}:host,html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]:where(:not([hidden=until-found])){display:none}.relative{position:relative}.h-screen{height:100vh}.w-screen{width:100vw}.bg-black{--tw-bg-opacity:1;background-color:rgb(0 0 0 / var(--tw-bg-opacity, 1))}</style></head>
        <body class="bg-black h-screen w-screen relative">
            


    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mesh Gradient Background</title>
    <!-- Tailwind CSS for basic utilities and responsive design -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom CSS for mesh gradients and animations */
        body {
            /* Set a black background for the entire page */
            background-color: black;
            /* Hide scrollbars to prevent them from appearing due to absolute positioning */
            overflow: hidden;
            /* Hide the default cursor to show only our custom gradient circle */
            cursor: none;
            /* Use Inter font as per guidelines */
            font-family: 'Inter', sans-serif;
        }

        /* Base styles for all gradient circles */
        .gradient-circle {
            position: absolute; /* Allows for precise positioning using top/left */
            width: 300px;
            height: 300px;
            border-radius: 50%; /* Makes the elements perfectly circular */
            /* Apply a strong blur filter to create the 'mesh gradient' ethereal effect */
            filter: blur(100px);
            opacity: 0.8; /* Slightly transparent to allow for layering */
            /* Prevents the circles from blocking mouse events on elements beneath them */
            pointer-events: none;
            /* Smooth transitions for size, background, and opacity changes */
            transition: transform 0.1s ease-out, background 0.3s ease-in-out, width 0.3s ease-in-out, height 0.3s ease-in-out, opacity 0.3s ease-in-out;
        }

        /* Specific styles for the red gradient circle */
        .gradient-red {
            background: radial-gradient(circle at center, #ff007f, #ff4d94, #660033); /* Red/Pink gradient */
            /* Apply a linear rotation animation */
            animation: rotateRandom 20s linear infinite;
        }

        /* Specific styles for the blue gradient circle */
        .gradient-blue {
            background: radial-gradient(circle at center, #00bfff, #007bff, #003366); /* Light Blue/Blue gradient */
            /* Apply a linear rotation animation in reverse direction */
            animation: rotateRandom 25s linear infinite reverse;
        }

        /* Specific styles for the pink gradient circle */
        .gradient-pink {
            background: radial-gradient(circle at center, #ff00ff, #ff66ff, #990099); /* Bright Pink/Magenta gradient */
            /* Apply a linear rotation animation */
            animation: rotateRandom 18s linear infinite;
        }

        /* Specific styles for the purple mouse-following gradient circle */
        .gradient-purple-mouse {
            background: radial-gradient(circle at center, #9933ff, #6600cc, #330066); /* Purple gradient */
            z-index: 100; /* Ensure this circle stays on top of others */
            width: 150px; /* Initial size of the mouse follower */
            height: 150px;
            /* Slightly less blur for a more defined look for the interactive element */
            filter: blur(80px);
            /* Faster transform transition for smoother mouse following */
            transition: transform 0.05s ease-out, background 0.3s ease-in-out, width 0.3s ease-in-out, height 0.3s ease-in-out;
        }

        /* Keyframe animation for continuous rotation */
        @keyframes rotateRandom {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Responsive adjustments for smaller screens (tablets and mobile) */
        @media (max-width: 768px) {
            .gradient-circle {
                width: 200px; /* Smaller size for fixed circles */
                height: 200px;
                filter: blur(80px); /* Adjust blur intensity */
            }
            .gradient-purple-mouse {
                width: 100px; /* Smaller size for mouse circle */
                height: 100px;
                filter: blur(60px); /* Adjust blur intensity */
            }
        }
    </style>



    <!-- The three static gradient circles -->
    <div id="red-circle" class="gradient-circle gradient-red" style="left: 310px; top: 313px; opacity: 0.8; pointer-events: none; background: radial-gradient(circle, rgb(255, 0, 127), rgb(255, 77, 148), rgb(102, 0, 51));"></div>
    <div id="blue-circle" class="gradient-circle gradient-blue" style="left: 639px; top: 40.6px; opacity: 0.8; pointer-events: none; background: radial-gradient(circle, rgb(0, 191, 255), rgb(0, 123, 255), rgb(0, 51, 102));"></div>
    <div id="pink-circle" class="gradient-circle gradient-pink" style="left: 908.2px; top: 169.5px; opacity: 0.8; pointer-events: none; background: radial-gradient(circle, rgb(255, 0, 255), rgb(255, 102, 255), rgb(153, 0, 153));"></div>

    <!-- The mouse-following gradient circle -->
    <div id="mouse-circle" class="gradient-circle gradient-purple-mouse" style="left: 147px; top: -68px; width: 150px; height: 150px; background: radial-gradient(circle, rgb(153, 51, 255), rgb(102, 0, 204), rgb(51, 0, 102));"></div>

    <script>
        // Get references to the DOM elements
        const mouseCircle = document.getElementById('mouse-circle');
        const fixedCircles = [
            // Store fixed circle elements along with their original colors and velocity for movement
            { element: document.getElementById('red-circle'), color: 'red', initialColor: 'radial-gradient(circle at center, #ff007f, #ff4d94, #660033)', vx: 1.5, vy: 1.0 },
            { element: document.getElementById('blue-circle'), color: 'blue', initialColor: 'radial-gradient(circle at center, #00bfff, #007bff, #003366)', vx: -1.0, vy: 1.2 },
            { element: document.getElementById('pink-circle'), color: 'pink', initialColor: 'radial-gradient(circle at center, #ff00ff, #ff66ff, #990099)', vx: 1.2, vy: -1.5 }
        ];

        // Constants for mouse circle's initial state and morphing behavior
        const initialMouseColor = 'radial-gradient(circle at center, #9933ff, #6600cc, #330066)'; // Original purple color
        const initialMouseSize = 150; // Original size of the mouse follower
        const morphedMouseSize = 400; // Size when the mouse circle morphs/connects
        const morphThreshold = 150; // Distance in pixels to trigger morphing

        // Function to set random initial positions for the static circles
        function initializeFixedCirclePositions() {
            fixedCircles.forEach(circle => {
                // Calculate random X and Y coordinates within the window boundaries
                // Subtract element width/height to keep the entire circle on screen
                const x = Math.random() * (window.innerWidth - circle.element.offsetWidth);
                const y = Math.random() * (window.innerHeight - circle.element.offsetHeight);
                circle.element.style.left = `${x}px`;
                circle.element.style.top = `${y}px`;
                // Ensure visibility and interactivity when initially placed
                circle.element.style.opacity = 0.8;
                circle.element.style.pointerEvents = 'none'; // Keep pointer events off for fixed circles
                circle.element.style.background = circle.initialColor; // Reset color to original
            });
        }

        // Animation loop for fixed circles' movement
        function animateFixedCircles() {
            fixedCircles.forEach(circle => {
                const element = circle.element;
                let currentX = parseFloat(element.style.left);
                let currentY = parseFloat(element.style.top);

                // Update position based on velocity
                currentX += circle.vx;
                currentY += circle.vy;

                // Get dimensions to check boundaries
                const elementWidth = element.offsetWidth;
                const elementHeight = element.offsetHeight;

                // Boundary checks: bounce off the edges
                if (currentX + elementWidth > window.innerWidth || currentX < 0) {
                    circle.vx *= -1; // Reverse horizontal velocity
                    // Adjust position slightly to prevent sticking to the edge
                    if (currentX + elementWidth > window.innerWidth) currentX = window.innerWidth - elementWidth;
                    if (currentX < 0) currentX = 0;
                }
                if (currentY + elementHeight > window.innerHeight || currentY < 0) {
                    circle.vy *= -1; // Reverse vertical velocity
                    // Adjust position slightly to prevent sticking to the edge
                    if (currentY + elementHeight > window.innerHeight) currentY = window.innerHeight - elementHeight;
                    if (currentY < 0) currentY = 0;
                }

                // Apply updated position
                element.style.left = `${currentX}px`;
                element.style.top = `${currentY}px`;
            });

            // Request the next animation frame to continue the movement
            requestAnimationFrame(animateFixedCircles);
        }

        // Initialize positions and start the animation loop when the page loads
        window.onload = function() {
            initializeFixedCirclePositions();
            animateFixedCircles();
        };

        // Event listener for mouse movement
        document.addEventListener('mousemove', (e) => {
            const mouseX = e.clientX; // Current mouse X coordinate
            const mouseY = e.clientY; // Current mouse Y coordinate

            // Position the mouse circle relative to the cursor, centering it
            mouseCircle.style.left = `${mouseX - mouseCircle.offsetWidth / 2}px`;
            mouseCircle.style.top = `${mouseY - mouseCircle.offsetHeight / 2}px`;

            let closestCircle = null;
            let minDistance = Infinity;

            // Iterate over each fixed circle to check for proximity
            fixedCircles.forEach(circle => {
                const circleRect = circle.element.getBoundingClientRect();
                // Calculate the center coordinates of the fixed circle
                const circleX = circleRect.left + circleRect.width / 2;
                const circleY = circleRect.top + circleRect.height / 2;

                // Calculate the Euclidean distance between the mouse and fixed circle centers
                const distance = Math.sqrt(
                    Math.pow(mouseX - circleX, 2) + Math.pow(mouseY - circleY, 2)
                );

                // If this circle is closer than previous ones and within the threshold
                if (distance < minDistance && distance < morphThreshold) {
                    minDistance = distance;
                    closestCircle = circle;
                }
            });

            // Apply morphing effect based on proximity
            if (closestCircle) {
                // Morph effect: enlarge and change color to match the closest fixed circle
                mouseCircle.style.width = `${morphedMouseSize}px`;
                mouseCircle.style.height = `${morphedMouseSize}px`;
                mouseCircle.style.background = closestCircle.initialColor;
            } else {
                // Revert to initial state if no fixed circles are nearby
                mouseCircle.style.width = `${initialMouseSize}px`;
                mouseCircle.style.height = `${initialMouseSize}px`;
                mouseCircle.style.background = initialMouseColor;
            }
        });
    </script>



            <script>// Write JavaScript here</script>
        
    
</body>